
#include "TFT.h"
#include "stdlib.h"
#include "font.h"
#include "usart.h"
#include "delay.h"
#include "stdio.h"

//画笔颜色,背景颜色
u16 POINT_COLOR = 0x0000,BACK_COLOR = 0xFFFF;
u16 DeviceCode;

void LCD_WR_DATA(u16 inputdata)
{
    LCD_CS=0;
    LCD_RS=1;
    LCD_RD=1;
    LCD_WR=0;
    GPIOB->ODR=(GPIOB->ODR&0X00ff)|(inputdata&0xff00);
    LCD_WR=1;
    LCD_WR=0;
    GPIOB->ODR=(GPIOB->ODR&0X00ff)|(inputdata<<8);
    LCD_WR=1;

}
//写寄存器函数
void LCD_WR_REG(u16 data)
{
    LCD_CS=0;
    LCD_RS=0;//写地址
    LCD_RD=1;
    LCD_WR=0;
    GPIOB->ODR=(GPIOB->ODR&0X00ff)|(data&0xff00);
    LCD_WR=1;
    LCD_WR=0;
    GPIOB->ODR=(GPIOB->ODR&0X00ff)|(data<<8);
    LCD_WR=1;

}


//写寄存器
void LCD_WriteReg(u16 LCD_Reg, u16 LCD_RegValue)
{
    LCD_WR_REG(LCD_Reg);
    LCD_WR_DATA(LCD_RegValue);
}
//读寄存器
u16 LCD_ReadReg(u16 LCD_Reg)
{
    u16 t1,t2,t;
    LCD_WR_REG(LCD_Reg);  //写入要读的寄存器号
//	GPIOB->CRL=0X88888888; //PB0-7  上拉输入
    GPIOB->CRH=0X88888888; //PB8-15 上拉输入
//	GPIOB->ODR=0XFFFF;    //全部输出高

    VC245_FIFO=1;
    VC245_7670=1;
    LCD_CS=0;
    LCD_RS=1;
    //读取数据(读寄存器时,并不需要读2次)
    LCD_RD=0;
    LCD_RD=1;
    t1=(0xff00&GPIOB->IDR);

    LCD_RD=0;
    LCD_RD=1;
    t2=(0xff00&GPIOB->IDR);
    t=(t2>>8)|t1;

//	GPIOB->CRL=0X33333333; //PB0-7  上拉输出
    GPIOB->CRH=0X33333333; //PB8-15 上拉输出
//	GPIOB->ODR=0XFFFF;    //全部输出高
    return t;
}
//开始写GRAM
void LCD_WriteRAM_Prepare(void)
{
    LCD_WR_REG(R34);
}
//LCD写GRAM
void LCD_WriteRAM(u16 RGB_Code)
{
    LCD_WR_DATA(RGB_Code);//写十六位GRAM
}

//初始化lcd
void LCD_Init(void)
{
    RCC->APB2ENR|=1<<3;//先使能外设PORTB时钟
    RCC->APB2ENR|=1<<4;//先使能外设PORTC时钟

    RCC->APB2ENR|=1<<0;    //开启辅助时钟
    //PORTB 推挽输出
    GPIOB->CRH=0X33333333;
    GPIOB->CRL=0X33333333;
//	GPIOB->ODR=0XFFFF;

    GPIOC->CRH=0X33333333;
    GPIOC->CRL=0X33388888; 	 //pc0..4 is input
    GPIOC->ODR=0XFFFF;

    VC245_7670=1;
    VC245_FIFO=1;

    LCD_CS = 0;
    LCD_RST=0;
    delay_ms(1000);
    LCD_RST=1;
    delay_ms(50); // delay 50 ms
    LCD_WriteReg(0x0000,0x0001);
    delay_ms(50); // delay 50 ms
    DeviceCode = LCD_ReadReg(0x0000);
    printf(" LCD ID:%x\n",DeviceCode); //打印LCD ID
    LCD_WriteReg(0x00e7,0x0010);
    LCD_WriteReg(0x0000,0x0001);//开启内部时钟
    LCD_WriteReg(0x0001,0x0100);
    LCD_WriteReg(0x0002,0x0700);//电源开启
    LCD_WriteReg(0x0003,(1<<12)|(3<<4)|(0<<3) );
    LCD_WriteReg(0x0004,0x0000);
    LCD_WriteReg(0x0008,0x0207);
    LCD_WriteReg(0x0009,0x0000);
    LCD_WriteReg(0x000a,0x0000);
    LCD_WriteReg(0x000c,0x0001);
    LCD_WriteReg(0x000d,0x0000);
    LCD_WriteReg(0x000f,0x0000);
    //电源配置
    LCD_WriteReg(0x0010,0x0000);
    LCD_WriteReg(0x0011,0x0007);
    LCD_WriteReg(0x0012,0x0000);
    LCD_WriteReg(0x0013,0x0000);
    delay_ms(50);
    LCD_WriteReg(0x0010,0x1590);
    LCD_WriteReg(0x0011,0x0227);
    delay_ms(50);
    LCD_WriteReg(0x0012,0x009c);
    delay_ms(50);
    LCD_WriteReg(0x0013,0x1900);
    LCD_WriteReg(0x0029,0x0023);
    LCD_WriteReg(0x002b,0x000e);
    delay_ms(50);
    LCD_WriteReg(0x0020,0x0000);
    LCD_WriteReg(0x0021,0x013f);
    delay_ms(50);
    //伽马校正
    LCD_WriteReg(0x0030,0x0007);
    LCD_WriteReg(0x0031,0x0707);
    LCD_WriteReg(0x0032,0x0006);
    LCD_WriteReg(0x0035,0x0704);
    LCD_WriteReg(0x0036,0x1f04);
    LCD_WriteReg(0x0037,0x0004);
    LCD_WriteReg(0x0038,0x0000);
    LCD_WriteReg(0x0039,0x0706);
    LCD_WriteReg(0x003c,0x0701);
    LCD_WriteReg(0x003d,0x000f);
    delay_ms(50);
    LCD_WriteReg(0x0050,0x0000); //水平GRAM起始位置
    LCD_WriteReg(0x0051,0x00ef); //水平GRAM终止位置
    LCD_WriteReg(0x0052,0x0000); //垂直GRAM起始位置
    LCD_WriteReg(0x0053,0x013f); //垂直GRAM终止位置

    LCD_WriteReg(0x0060,0xa700);
    LCD_WriteReg(0x0061,0x0001);
    LCD_WriteReg(0x006a,0x0000);
    LCD_WriteReg(0x0080,0x0000);
    LCD_WriteReg(0x0081,0x0000);
    LCD_WriteReg(0x0082,0x0000);
    LCD_WriteReg(0x0083,0x0000);
    LCD_WriteReg(0x0084,0x0000);
    LCD_WriteReg(0x0085,0x0000);

    LCD_WriteReg(0x0090,0x0010);
    LCD_WriteReg(0x0092,0x0000);
    LCD_WriteReg(0x0093,0x0003);
    LCD_WriteReg(0x0095,0x0110);
    LCD_WriteReg(0x0097,0x0000);
    LCD_WriteReg(0x0098,0x0000);
    //开启显示设置
    LCD_WriteReg(0x0007,0x0133);
    LCD_WriteReg(0x0020,0x0000);
    LCD_WriteReg(0x0021,0x013f);
    LCD_Clear(BLACK);
}


//从ILI93xx读出的数据为GBR格式，而我们写入的时候为RGB格式。
//通过该函数转换
//c:GBR格式的颜色值
//返回值：RGB格式的颜色值
u16 LCD_BGR2RGB(u16 c)
{
    u16  r,g,b,rgb;
    b=(c>>0)&0x1f;
    g=(c>>5)&0x3f;
    r=(c>>11)&0x1f;
    rgb=(b<<11)+(g<<5)+(r<<0);
    return(rgb);
}
//读取个某点的颜色值
//x:0~239
//y:0~319
//返回值:此点的颜色
u16 LCD_ReadPoint(u16 x,u16 y)
{
    u16 t;
    if(x>=LCD_W||y>=LCD_H)return 0;//超过了范围,直接返回
    LCD_SetCursor(x,y);
    LCD_WR_REG(R34);       //选择GRAM地址
    GPIOB->CRL=0X88888888; //PB0-7  上拉输入
    GPIOB->CRH=0X88888888; //PB8-15 上拉输入
    GPIOB->ODR=0XFFFF;     //全部输出高

    LCD_RS=1;
    //读取数据(读GRAM时,需要读2次)
    LCD_RD=0;
    LCD_RD=1;
    //dummy READ
    LCD_RD=0;
    LCD_RD=1;
    t=DATAIN;

    GPIOB->CRL=0X33333333; //PB0-7  上拉输出
    GPIOB->CRH=0X33333333; //PB8-15 上拉输出
    GPIOB->ODR=0XFFFF;    //全部输出高
    if(DeviceCode==0X4531||DeviceCode==0X8989)return t;//4531/8989驱动IC
    else return LCD_BGR2RGB(t);
}
//LCD开启显示
void LCD_DisplayOn(void)
{
    LCD_WriteReg(R7, 0x0173); //26万色显示开启
}
//LCD关闭显示
void LCD_DisplayOff(void)
{
    LCD_WriteReg(R7, 0x0);//关闭显示
}
//设置光标位置
//Xpos:横坐标
//Ypos:纵坐标
__inline void LCD_SetCursor(u16 Xpos, u16 Ypos)
{
#ifdef USE_HORIZONTAL
    if(DeviceCode==0X8989)
    {
        LCD_WriteReg(0X4E, Ypos);
        LCD_WriteReg(0X4F, 319-Xpos);
    } else
    {
        LCD_WriteReg(R32, Ypos);
        LCD_WriteReg(R33, 319-Xpos);
    }
#else
    if(DeviceCode==0X8989)
    {
        LCD_WriteReg(0X4E, Xpos);
        LCD_WriteReg(0X4F, Ypos);
    } else
    {
        LCD_WriteReg(R32, Xpos);
        LCD_WriteReg(R33, Ypos);
    }
#endif
}
//画点
//x:0~239
//y:0~319
//POINT_COLOR:此点的颜色
void LCD_DrawPoint(u16 x,u16 y)
{
    LCD_SetCursor(x,y);//设置光标位置
    LCD_WR_REG(R34);//开始写入GRAM
    LCD_WR_DATA(POINT_COLOR);
}


//清屏函数
//Color:要清屏的填充色
void LCD_Clear(u16 Color)
{
    u32 index=0;
    LCD_SetCursor(0x00,0x0000);//设置光标位置
    LCD_WriteRAM_Prepare();     //开始写入GRAM
    for(index=0; index<76800; index++)
    {
        LCD_WR_DATA(Color);
    }
}
//在指定区域内填充指定颜色
//区域大小:
//  (xend-xsta)*(yend-ysta)
void LCD_Fill(u16 xsta,u16 ysta,u16 xend,u16 yend,u16 color)
{
    u16 i,j;
    u16 xlen=0;
#ifdef USE_HORIZONTAL
    xlen=yend-ysta+1;
    for(i=xsta; i<=xend; i++)
    {
        LCD_SetCursor(i,ysta);      //设置光标位置
        LCD_WriteRAM_Prepare();     //开始写入GRAM
        for(j=0; j<xlen; j++)LCD_WR_DATA(color); //设置光标位置
    }
#else
    xlen=xend-xsta+1;
    for(i=ysta; i<=yend; i++)
    {
        LCD_SetCursor(xsta,i);      //设置光标位置
        LCD_WriteRAM_Prepare();     //开始写入GRAM
        for(j=0; j<xlen; j++)LCD_WR_DATA(color); //设置光标位置
    }
#endif
}
//画线
//x1,y1:起点坐标
//x2,y2:终点坐标
void LCD_DrawLine(u16 x1, u16 y1, u16 x2, u16 y2)
{
    u16 t;
    int xerr=0,yerr=0,delta_x,delta_y,distance;
    int incx,incy,uRow,uCol;

    delta_x=x2-x1; //计算坐标增量
    delta_y=y2-y1;
    uRow=x1;
    uCol=y1;
    if(delta_x>0)incx=1; //设置单步方向
    else if(delta_x==0)incx=0;//垂直线
    else {
        incx=-1;
        delta_x=-delta_x;
    }
    if(delta_y>0)incy=1;
    else if(delta_y==0)incy=0;//水平线
    else {
        incy=-1;
        delta_y=-delta_y;
    }
    if( delta_x>delta_y)distance=delta_x; //选取基本增量坐标轴
    else distance=delta_y;
    for(t=0; t<=distance+1; t++ ) //画线输出
    {
        LCD_DrawPoint(uRow,uCol);//画点
        xerr+=delta_x ;
        yerr+=delta_y ;
        if(xerr>distance)
        {
            xerr-=distance;
            uRow+=incx;
        }
        if(yerr>distance)
        {
            yerr-=distance;
            uCol+=incy;
        }
    }
}
//画矩形
void LCD_DrawRectangle(u16 x1, u16 y1, u16 x2, u16 y2)
{
    LCD_DrawLine(x1,y1,x2,y1);
    LCD_DrawLine(x1,y1,x1,y2);
    LCD_DrawLine(x1,y2,x2,y2);
    LCD_DrawLine(x2,y1,x2,y2);
}
//在指定位置画一个指定大小的圆
//(x,y):中心点
//r    :半径
void Draw_Circle(u16 x0,u16 y0,u8 r)
{
    int a,b;
    int di;
    a=0;
    b=r;
    di=3-(r<<1);             //判断下个点位置的标志
    while(a<=b)
    {
        LCD_DrawPoint(x0-b,y0-a);             //3
        LCD_DrawPoint(x0+b,y0-a);             //0
        LCD_DrawPoint(x0-a,y0+b);             //1
        LCD_DrawPoint(x0-b,y0-a);             //7
        LCD_DrawPoint(x0-a,y0-b);             //2
        LCD_DrawPoint(x0+b,y0+a);             //4
        LCD_DrawPoint(x0+a,y0-b);             //5
        LCD_DrawPoint(x0+a,y0+b);             //6
        LCD_DrawPoint(x0-b,y0+a);
        a++;
        //使用Bresenham算法画圆
        if(di<0)di +=4*a+6;
        else
        {
            di+=10+4*(a-b);
            b--;
        }
        LCD_DrawPoint(x0+a,y0+b);
    }
}
//在指定位置显示一个字符
//x:0~234
//y:0~308
//num:要显示的字符:" "--->"~"
//size:字体大小 12/16
//mode:叠加方式(1)还是非叠加方式(0)
//在指定位置显示一个字符
//x:0~234
//y:0~308
//num:要显示的字符:" "--->"~"
//size:字体大小 12/16
//mode:叠加方式(1)还是非叠加方式(0)
void LCD_ShowChar(u16 x,u16 y,u8 num,u8 size,u8 mode)
{
#ifdef USE_HORIZONTAL
#define MAX_CHAR_POSX 312
#define MAX_CHAR_POSY 232
#else
#define MAX_CHAR_POSX 232
#define MAX_CHAR_POSY 312
#endif
    u8 temp;
    u8 pos,t;
    u16 x0=x;
    u16 colortemp=POINT_COLOR;
    if(x>MAX_CHAR_POSX||y>MAX_CHAR_POSY)return;
    //设置窗口
    num=num-' ';//得到偏移后的值
    if(!mode) //非叠加方式
    {
        for(pos=0; pos<size; pos++)
        {
            if(size==12)temp=asc2_1206[num][pos];//调用1206字体
            else temp=asc2_1608[num][pos];		 //调用1608字体
            for(t=0; t<size/2; t++)
            {
                if(temp&0x01)POINT_COLOR=colortemp;
                else POINT_COLOR=BACK_COLOR;
                LCD_DrawPoint(x,y);
                temp>>=1;
                x++;
            }
            x=x0;
            y++;
        }
    } else//叠加方式
    {
        for(pos=0; pos<size; pos++)
        {
            if(size==12)temp=asc2_1206[num][pos];//调用1206字体
            else temp=asc2_1608[num][pos];		 //调用1608字体
            for(t=0; t<size/2; t++)
            {
                if(temp&0x01)LCD_DrawPoint(x+t,y+pos);//画一个点
                temp>>=1;
            }
        }
    }
    POINT_COLOR=colortemp;
}
//m^n函数
u32 mypow(u8 m,u8 n)
{
    u32 result=1;
    while(n--)result*=m;
    return result;
}
//显示2个数字
//x,y :起点坐标
//len :数字的位数
//size:字体大小
//color:颜色
//num:数值(0~4294967295);
void LCD_ShowNum(u16 x,u16 y,u32 num,u8 len,u8 size)
{
    u8 t,temp;
    u8 enshow=0;
    for(t=0; t<len; t++)
    {
        temp=(num/mypow(10,len-t-1))%10;
        if(enshow==0&&t<(len-1))
        {
            if(temp==0)
            {
                LCD_ShowChar(x+(size/2)*t,y,' ',size,0);
                continue;
            } else enshow=1;

        }
        LCD_ShowChar(x+(size/2)*t,y,temp+'0',size,0);
    }
}
//显示2个数字
//x,y:起点坐标
//size:字体大小
//mode:模式	0,填充模式;1,叠加模式
//num:数值(0~99);
void LCD_Show2Num(u16 x,u16 y,u16 num,u8 len,u8 size,u8 mode)
{
    u8 t,temp;
    for(t=0; t<len; t++)
    {
        temp=(num/mypow(10,len-t-1))%10;
        LCD_ShowChar(x+(size/2)*t,y,temp+'0',size,mode);
    }
}
//显示字符串
//x,y:起点坐标
//*p:字符串起始地址
//用16字体
void LCD_ShowString(u16 x,u16 y,const u8 *p)
{
    while(*p!='\0')
    {
        if(x>MAX_CHAR_POSX) {
            x=0;
            y+=16;
        }
        if(y>MAX_CHAR_POSY) {
            y=x=0;
        }
        LCD_ShowChar(x,y,*p,16,0);
        x+=8;
        p++;
    }
}
